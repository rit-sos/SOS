SOS Build System
Authors: Corey Bloodstein

[Purpose]
With the addition of the memory management module (discussed in
mman.txt), user programs all need their own separate virtual address
spaces, which are distinct from the kernel address space. The new
build system creates separate program images for each user program
and allows the kernel to dispatch copies of the program with exec().
Unlike the baseline system, each copy of the program gets its own
set of global variables and code using the copy-on-write mechanism.

[Design]
The new build system creates separate executable images for each
user program, as well as for the kernel and bootstrap.

Building the bootstrap is straightforward and requires no changes from
the baseline build system.

The kernel is built with a base address at an offset of KERNEL_BASE
out of the pieces listed in the KERNEL_BITS variable. KERNEL_BITS
contains a list of all of the modules in the order that they should be
linked in. It is therefore important that startup.o is the first
module, and that the entry code (_start) is at the very beginning of
startup.o.

User programs are built with a base address of USER_BASE for every
user program. This way, when the program is started by the kernel, the
program image can always be mapped to the same place in the target
process's address space and the program's starting EIP can always be
set to USER_BASE, despite the different programs residing on different
physical pages. The user programs are also mapped into the user
process address spaces copy-on-write. Because of this, if the program
writes to its code or global variables, it gets its own private copy
of the page that it wrote to so that multiple copies of the same
program can be run at the same time. The user programs also contain
private copies of each of the user libraries as listed in USER_BITS.
The libraries have the same copy-on-write benefit for the use of
global variables.

User programs are linked slightly differently compared to the kernel
and boostrap. In addition to the program's object file and the user
libraries, another small object file is linked in, called the ustrap.
The ustrap is contained in ustrap.S, a short assembly stub that is
built and linked into each user program at the very beginning of the
program image. This way, each user program runs the ustrap code first.
This provides a three benefits. First, and most importantly, the
ustrap code calls the program's main function. Without ustrap, if the
first function defined in the program's main source file is not main,
the first function would be the entry point instead of main. Ustrap
avoids this problem. Second, ustrap is able to set the return address
before jumping into main. This allows the return address to be set to
the address of the process's local exit() function, which will be at
a different offset in each program image. Finally, the ustrap code is
also used to call heap_init() to set up the process's heap manager.

The user programs still need to be built into the bootable image to
get them into memory in the first place. This is accomplished using
the map file and mkmap.sh. The map file is a simple table that must
be updated with each new user program. Each user program is one line
of the map file, with the program name in the first column and the
desired offset into the boot image in the second column. During the
build process, the shell script mkmap.sh is run to generate umap.h,
kmap.h, and kmap.c. The header files are used by the user programs
and kernel respectively to refer to program images by an automatically
generated ID number. The kernel version also contains the addresses
of the program images. The kmap.c file contains a global table for
use in the kernel such that program IDs can be translated into
addresses for loading program images. The program ID is also stored
in the PCB of each process.

The bootable image itself is generated by passing the offsets from
the map file to the BuildImage program provided with the baseline.
The resulting image format is effectively the same as the baseline's,
except for the addition of spaces between the loaded images.

The build system also generates .nl files for the kernel and each of
the separate program images, as well as .lst files for assembly
source files.

[Interface]
Kernel modules are added by adding <module_name>.o to the KERNEL_BITS
variable in the Makefile. User library modules, which are included in
each user program image, are similarly added by adding <module_name>.o
to the USER_BITS variable.

The base address of the user programs can be adjusted by changing the
USER_BASE variable.

To add a user program to the build, the user program's name must be
added to the USERS variable. The user program has also has to be added
to the build image map, as discussed above.

Writing a new user program is as simple as making a <program_name>.c
file with a function with the prototype "void main(void)".
